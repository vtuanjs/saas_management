// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: refresh_token.sql

package sqlc

import (
	"context"
	"time"
)

const getRefreshTokenByID = `-- name: GetRefreshTokenByID :one
SELECT id, token_id, expires_at, device, ip, user_id, created_at, updated_at, version FROM refresh_tokens WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRefreshTokenByID(ctx context.Context, id string) (*RefreshToken, error) {
	row := q.db.QueryRow(ctx, getRefreshTokenByID, id)
	var i RefreshToken
	err := row.Scan(
		&i.ID,
		&i.TokenID,
		&i.ExpiresAt,
		&i.Device,
		&i.Ip,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
	)
	return &i, err
}

const saveRefreshToken = `-- name: SaveRefreshToken :one
INSERT INTO refresh_tokens (
    id,
    token_id,
    expires_at,
    device,
    ip,
    user_id,
    created_at,
    updated_at
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
ON CONFLICT (id) DO UPDATE
SET
    token_id = EXCLUDED.token_id,
    expires_at = EXCLUDED.expires_at,
    device = EXCLUDED.device,
    ip = EXCLUDED.ip,
    user_id = EXCLUDED.user_id,
    updated_at = EXCLUDED.updated_at,
    version = refresh_tokens.version + 1
RETURNING id, token_id, expires_at, device, ip, user_id, created_at, updated_at, version
`

type SaveRefreshTokenParams struct {
	ID        string
	TokenID   string
	ExpiresAt *time.Time
	Device    []byte
	Ip        string
	UserID    string
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) SaveRefreshToken(ctx context.Context, arg SaveRefreshTokenParams) (*RefreshToken, error) {
	row := q.db.QueryRow(ctx, saveRefreshToken,
		arg.ID,
		arg.TokenID,
		arg.ExpiresAt,
		arg.Device,
		arg.Ip,
		arg.UserID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i RefreshToken
	err := row.Scan(
		&i.ID,
		&i.TokenID,
		&i.ExpiresAt,
		&i.Device,
		&i.Ip,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
	)
	return &i, err
}
